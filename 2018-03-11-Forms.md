---
title: Forms
layout: post
author: kimchristian3426
permalink: /forms/
source-id: 197QiLtINajnCxMtVv15k7nP2L4CFo_DA7m7PqLFYTOw
published: true
---
[User Input](https://angular.io/guide/user-input#user-input)

사용자는 링크 클릭, 버틀 클릭, 텍스트 엔터등의 DOM 이벤트들을 일으킨다. 이 페이지에서는 어떻게 컴포넌트에서 이벤트 핸들링을 앵귤러 이벤트 바인딩 문법을 사용하여 하는지 설명한다.

Run the [live example](https://angular.io/generated/live-examples/user-input/stackblitz.html) / [download example](https://angular.io/generated/zips/user-input/user-input.zip).

# [Binding to user input events](https://angular.io/guide/user-input#binding-to-user-input-events)

	당신은 Dom 이벤트([DOM event](https://developer.mozilla.org/en-US/docs/Web/Events))에 반응하여 앵귤러 이벤트 바인딩([Angular event bindings](https://angular.io/guide/template-syntax#event-binding))들을 할수 있다. 많은 DOM 이벤트들을 유저 입력에 발동한다. 이러한 이벤트 바인딩은 유저의 입력을 얻는 방법이다. Dom 이벤트에 바인딩 하기 위해서. 괄호 속에 이벤트명을 둘러싸고 템플릿 선언으로 이것을 할당한다. 아래에 클릭 핸들러를 구현한 이벤트 바인딩을 보여주고 있다.

<pre>
	&lt;button (click)="onClickMe()"&gt;Click me!&lt;/button&gt;
</pre>

	

## [Get user input from the $event object](https://angular.io/guide/user-input#get-user-input-from-the-event-object)

    1. [Type the ](https://angular.io/guide/user-input#type-the-event)*[$even*t](https://angular.io/guide/user-input#type-the-event)

    2. [Passing ](https://angular.io/guide/user-input#passing-event-is-a-dubious-practice)*[$even*t](https://angular.io/guide/user-input#passing-event-is-a-dubious-practice)[ is a dubious practice](https://angular.io/guide/user-input#passing-event-is-a-dubious-practice)

		이벤트 객체 타입핑은 전체 전체 돔의 이벤트가 메소드로 통과할때 아주 중요한 사항을 밝혀낸다: 컴포넌트는 너무 많은 템플릿에 상세함에 대한 자각을 가진다. 이것은 HTML 구현에 대한 것을 알아야 하는 것 없이는 정보를 추출할수 없다. 이것은 템플릿과 컴포넌트 사이의 관심사 분리를 깨지게 한다.

		그 다음은 섹션에서는 이 문제에 대해서 템플릿 레퍼런스 변수들을 사용하는 것을 보여준다.

<pre>
	@Component({
  	selector: 'app-loop-back',
  	template: `
    	&lt;input #box (keyup)="0"&gt;
    	&lt;p&gt;{{box.value}}&lt;/p&gt;
  	`
	})
	export class LoopbackComponent { }
</pre>

	

	The template reference variable named box, declared on the <input> element, refers to the <input> element itself. The code uses the box variable to get the input element's value and display it with interpolation between <p> tags. <input> 엘리멘트에 선언된 box로 네이밍한 템플릿 레퍼런스 변수는 ,  <input> 엘리멘트 자체를 참조한다. 코드에서 box 변수는 input 변수의 값을 얻기 위해서 사용되고 <p> 태그들 사이에 interpolation으로 나타낸다.	The template is completely self contained. It doesn't bind to the component, and the component does nothing. 템플릿은 자체로 포험되었다. 이것은 컴포넌트에 바인드 되지않았고 컴포넌트는 아무것도 하지 않았다.Type something in the input box, and watch the display update with each keystroke.

1. [Get user input from a template reference variable](https://angular.io/guide/user-input#get-user-input-from-a-template-reference-variable)

	유저 데이터를 얻는 다른 방법이 있다: 사용하라 앵귤러 템플릿 레퍼런스 변수를. 템플릿 레퍼런스 변수는 템플릿 이내에 있는 엘리멘트에 직접적인 엑세스를 제공한다. 템플릿 레퍼런스 변수를 선언하기 위해서 해시 문자열을 가진 인식자로 한다. 

	다음 예는 간단한 템플릿 안에서 키스크로크 루프백을 구현한 템플릿 변수를 사용한 예이다.

<pre>
	&lt;input #box (keyup)="0"&gt;	 &lt;p&gt;{{box.value}}&lt;/p&gt;
</pre>

	

		It's easier to get to the input box with the template reference variable than to go through the $eventobject. Here's a rewrite of the previous keyup example that uses a template reference variable to get the user's input.  $event  객체를 통해서 보다 , 템플릿 레퍼런스 변수를 가진 input box 를 얻는것이 더 쉽다. 여기 템플릿 레퍼런스 변수로 사용자의 입력을 얻는 방법이 사용된 KeyUp 이전 예제를 다시 작성했다.

<pre>
@[Component](https://angular.io/api/core/Component)({ selector: 'app-key-up2', template: ` &lt;input #box (keyup)="onKey(box.value)"&gt;  &lt;p&gt;{{values}}&lt;/p&gt;  		`})export class KeyUpComponent_v2 {values = '';  onKey(value: string) {this.values += value + ' | ';  }}
</pre>

		A nice aspect of this approach is that the component gets clean data values from the view. It no longer requires knowledge of the $event and its structure.

2. [Key event filtering (with ](https://angular.io/guide/user-input#key-event-filtering-with-keyenter)[key.enter](https://angular.io/guide/user-input#key-event-filtering-with-keyenter)[)](https://angular.io/guide/user-input#key-event-filtering-with-keyenter)

	The (keyup) event handler hears *every keystroke*. Sometimes only the *Enter* key matters, because it signals that the user has finished typing. One way to reduce the noise would be to examine every $event.keyCode and take action only when the key is *Enter*.

There's an easier way: bind to Angular's keyup.enter pseudo-event. Then Angular calls the event handler only when the user presses *Enter*.

<pre>
	@[Component](https://angular.io/api/core/Component)({ 	 selector: 'app-key-up3',  	template: `    	&lt;input #box (keyup.enter)="onEnter(box.value)"&gt;    	&lt;p&gt;{{value}}&lt;/p&gt;  	`	})	export class KeyUpComponent_v3 {  	value = '';  	onEnter(value: string) { this.value = value; }	}
</pre>

3. [On blur](https://angular.io/guide/user-input#on-blur)

4. [Put it all together](https://angular.io/guide/user-input#put-it-all-together)

    3. [Observations](https://angular.io/guide/user-input#observations)

5. [Source code](https://angular.io/guide/user-input#source-code)

6. [Summary](https://angular.io/guide/user-input#summary)

